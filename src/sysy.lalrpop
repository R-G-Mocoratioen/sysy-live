use crate::ast::*;
use crate::gen_music::*;

// lalrpop 里的约定
grammar;

// 约束 lexer 的行为
match {
  // 跳过空白符和注释
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},
  // 剩下的情况采用默认方式处理
  _
}

// 定义 CompUnit, 其返回值类型为 String
// parser 在解析完成后的行为是返回 FuncDef 的值
pub CompUnit: CompUnit = {
    <def: GlobalDef+> => {
        let mut func_defs = Vec::new();
        let mut global_var_defs = Vec::new();
        for item in def.into_iter() {
            match item {
                GlobalDef::FuncDef(funcdef) => func_defs.push(funcdef),
                GlobalDef::Decl(decl) => global_var_defs.push(decl),
            }
        }
        return CompUnit { func_defs: func_defs, global_var_defs: global_var_defs };
    },
}

GlobalDef: GlobalDef = {
    <decl: Decl> => GlobalDef::Decl(decl),
    "int" <id: Ident> "(" <params: FuncDefParams?> ")" <block: Block> => {
        return GlobalDef::FuncDef(FuncDef {
            func_type: FuncType::Int, params: params.unwrap_or(Vec::new()), id: id, block: block 
        });
    },
    "void" <id: Ident> "(" <params: FuncDefParams?> ")" <block: Block> => {
        return GlobalDef::FuncDef(FuncDef {
            func_type: FuncType::Void, params: params.unwrap_or(Vec::new()), id: id, block: block 
        });
    }
}

FuncDefParams: Vec<FuncParam> = {
    <par: FuncDefParam> <restpar: ("," FuncDefParam)*> => {
        let mut params = Vec::new();
        params.push(par);
        for (_, item) in restpar.into_iter() {
            params.push(item);
        }
        return params;
    },
}

FuncDefParam: FuncParam = {
    "int" <id: Ident> => FuncParam::Var(id),
    "int" <id: Ident> "[" "]" <dims: ("[" Exp "]")*> => {
        let mut exps = Vec::new();
        for (_, item, _) in dims.into_iter() {
            exps.push(Box::new(item));
        }
        return FuncParam::Array(id, exps);
    },
}

MusicDecl: VarDef = {
    "Score" <id: Ident> "(" "syllablename" "=" "\"" <score: Score> "\"" ")" ";" => {
        return VarDef::ScoreInit(id, Box::new(score));
    },
    "Note" <id: Ident> "(" "syllablename" "=" "\"" <note: Note> "\"" "," "duration" "=" "\"" <fz: IntConst> "/" <fm: IntConst> "\"" ")" ";" => {
        return VarDef::NoteInit(id, Box::new(note), fz, fm);
    },
    "Bar" <id: Ident> "(" "syllablename" "=" "\"" <bar: Bar> "\"" ")" ";" => {
        return VarDef::BarInit(id, Box::new(bar));
    },
    "Bar" <id: Ident> "(" <y: Exp> ")" ";" => {
        return VarDef::BarCopy(id, Box::new(y));
    },
    "Bar" <id: Ident> ";" => {
        return VarDef::Bar(id);
    },
    "Score" <id: Ident> "(" <y: Exp> ")" ";" => {
        return VarDef::ScoreCopy(id, Box::new(y));
    },
    "Score" <id: Ident> ";" => {
        return VarDef::Score(id);
    },
}

Decl: Decl = {
    "int" <firdef: VarDef> <restdef: ("," VarDef)*> ";" => {
        let mut decl = Vec::new();
        decl.push(Box::new(firdef));
        for (_, item) in restdef.into_iter() {
            decl.push(Box::new(item));
        }
        return Decl {defs: decl};
    },
    "const" "int" <firdef: ConstVarDef> <restdef: ("," ConstVarDef)*> ";" => {
        let mut decl = Vec::new();
        decl.push(Box::new(firdef));
        for (_, item) in restdef.into_iter() {
            decl.push(Box::new(item));
        }
        return Decl {defs: decl};
    },
    <musicdecl: MusicDecl> => Decl {defs: vec![Box::new(musicdecl)]},
    
}

ArrayInit: ArrayInit = {
    <exp: Exp> => ArrayInit::Single(Box::new(exp)),
    "{" "}" => ArrayInit::Multiple(Vec::new()),
    "{" <exp: ArrayInit> <restexp: ("," ArrayInit)*> "}" => {
        let mut exps = Vec::new();
        exps.push(Box::new(exp));
        for (_, item) in restexp.into_iter() {
            exps.push(Box::new(item));
        }
        return ArrayInit::Multiple(exps);
    },
}

VarDef: VarDef = {
    <id: Ident> => VarDef::Ident(id),
    <id: Ident> "=" <exp: Exp> => VarDef::IdentInit(id, Box::new(exp)),
    <id: Ident> <dims: ("[" Exp "]")+> => {
        let mut exps = Vec::new();
        for (_, item, _) in dims.into_iter() {
            exps.push(Box::new(item));
        }
        return VarDef::Array(id, exps);
    },
    <id: Ident> <dims: ("[" Exp "]")+> "=" <init: ArrayInit> => {
        let mut exps = Vec::new();
        for (_, item, _) in dims.into_iter() {
            exps.push(Box::new(item));
        }
        return VarDef::ArrayInit(id, exps, Box::new(init));
    }
}

ConstVarDef: VarDef = {
    <id: Ident> "=" <exp: Exp> => VarDef::ConstIdentInit(id, Box::new(exp)),
    <id: Ident> <dims: ("[" Exp "]")+> "=" <init: ArrayInit> => {
        let mut exps = Vec::new();
        for (_, item, _) in dims.into_iter() {
            exps.push(Box::new(item));
        }
        return VarDef::ArrayInit(id, exps, Box::new(init));
    }
}

FuncType: FuncType = {
    "int" => FuncType::Int,
    "void" => FuncType::Void,
}

Block: Block = "{" <blockitem: BlockItem*> "}" => {
    let mut block = Vec::new();
    for item in blockitem.into_iter() {
        block.push(Box::new(item));
    }
    return Block { vecitem: block };
};

BlockItem: BlockItem = {
    <stmt: Stmt> => BlockItem::Stmt(Box::new(stmt)),
    <decl: Decl> => BlockItem::Decl(Box::new(decl)),
}

OptionExp: Option<Exp> = Exp?;

MusicStmt: Stmt = {
    <x: Exp> "." "sing" "(" <a: Exp> "," <b: Exp> "," <c: Exp> "," <d: Exp> "," <e: Exp> ")" ";" => {
        return Stmt::Sing(Box::new(x), Box::new(a), Box::new(b), Box::new(c), Box::new(d), Box::new(e));
    },
    <x: Exp> "." "push_bar" "(" <a: Exp> ")" ";" => {
        return Stmt::PushBar(Box::new(x), Box::new(a));
    },
    <x: Exp> "." "push_note" "(" <a: Exp> ")" ";" => {
        return Stmt::PushNote(Box::new(x), Box::new(a));
    },
    <x: Exp> "." "set_bar_bpm" "(" <a: Exp> ")" ";" => {
        return Stmt::SetBarBpm(Box::new(x), Box::new(a));
    },
    <x: Exp> "." "set_score_bpm" "(" <a: Exp> ")" ";" => {
        return Stmt::SetScoreBpm(Box::new(x), Box::new(a));
    },
    <x: Exp> "." "inc_score_pitch" "(" <a: Exp> ")" ";" => {
        return Stmt::IncScorePitch(Box::new(x), Box::new(a));
    },
    <x: Exp> "." "set_score_duration" "(" <a: Exp> ")" ";" => {
        return Stmt::SetScoreDuration(Box::new(x), Box::new(a));
    },
    <x: Exp> "." "inc_bar_pitch" "(" <a: Exp> ")" ";" => {
        return Stmt::IncBarPitch(Box::new(x), Box::new(a));
    },
    <x: Exp> "." "set_bar_duration" "(" <a: Exp> ")" ";" => {
        return Stmt::SetBarDuration(Box::new(x), Box::new(a));
    },
    <x: Exp> "." "append" "(" <a: Exp> ")" ";" => {
        return Stmt::Append(Box::new(x), Box::new(a));
    },
    <x: Exp> "." "replace_bar" "(" <a: Exp> "," <b: Exp> ")" ";" => {
        return Stmt::ReplaceBar(Box::new(x), Box::new(a), Box::new(b));
    },
}

Stmt: Stmt = {
    <stmt: MatchedStmt> => <>,
    <stmt: UnMatchedStmt> => <>,
}

MatchedStmt: Stmt = {
    <lval: LVal> "=" <exp: Exp> ";" => Stmt::Assign(lval, Box::new(exp)),
    <optexp: OptionExp> ";" => Stmt::Do(Box::new(optexp)),
    "return" <optexp: OptionExp> ";" => Stmt::Return(Box::new(optexp)),
    <block: Block> => Stmt::Block(Box::new(block)),
    "if" "(" <exp: Exp> ")" <stmt1: MatchedStmt> "else" <stmt2: MatchedStmt> => Stmt::IfElse(Box::new(exp), Box::new(stmt1), Box::new(stmt2)),
    "while" "(" <exp: Exp> ")" <stmt: MatchedStmt> => Stmt::While(Box::new(exp), Box::new(stmt)),
    "break" ";" => Stmt::Break,
    "continue" ";" => Stmt::Continue,
    <musicstmt: MusicStmt> => musicstmt,
}

UnMatchedStmt: Stmt = {
    "if" "(" <exp: Exp> ")" <stmt: Stmt> => Stmt::If(Box::new(exp), Box::new(stmt)),
    "if" "(" <exp: Exp> ")" <stmt1: MatchedStmt> "else" <stmt2: UnMatchedStmt> => Stmt::IfElse(Box::new(exp), Box::new(stmt1), Box::new(stmt2)),
    "while" "(" <exp: Exp> ")" <stmt: UnMatchedStmt> => Stmt::While(Box::new(exp), Box::new(stmt)),
}

Exp: Exp = <lorexp: LOrExp> => Exp { lorexp: Box::new(lorexp) };

LVal: LVal = {
    <id: Ident> => LVal::Ident(id), // 注意：Ident 不一定就真的对应了一个 数组！
    <id: Ident> <dims: ("[" Exp "]")+> => {
        let mut exps = Vec::new();
        for (_, item, _) in dims.into_iter() {
            exps.push(Box::new(item));
        }
        return LVal::Array(id, exps);
    }
}

PrimaryExp: PrimaryExp = {
    "(" <exp: Exp> ")" => PrimaryExp::Exp(Box::new(exp)),
    <lval: LVal> => PrimaryExp::LVal(lval),
    <num: Number> => PrimaryExp::Number(num),
}

UnaryExp: UnaryExp = {
    <primexp: PrimaryExp> => UnaryExp::PrimaryExp(Box::new(primexp)),
    <id: Ident> "(" ")" => UnaryExp::FuncCall(id, Vec::new()),
    <id: Ident> "(" <args: FuncCallArgs> ")" => UnaryExp::FuncCall(id, args),
    "+" <unexp: UnaryExp> => UnaryExp::Pos(Box::new(unexp)),
    "-" <unexp: UnaryExp> => UnaryExp::Neg(Box::new(unexp)),
    "!" <unexp: UnaryExp> => UnaryExp::Not(Box::new(unexp)),
}

FuncCallArgs: Vec<Box<Exp>> = {
    <exp: Exp> <restexp: ("," Exp)*> => {
        let mut args = Vec::new();
        args.push(Box::new(exp));
        for (_, item) in restexp.into_iter() {
            args.push(Box::new(item));
        }
        return args;
    },
}

MulExp: MulExp = {
    <unexp: UnaryExp> => MulExp::UnaryExp(Box::new(unexp)),
    <mulexp: MulExp> "*" <unexp: UnaryExp> => MulExp::Mul(Box::new(mulexp), Box::new(unexp)),
    <mulexp: MulExp> "/" <unexp: UnaryExp> => MulExp::Div(Box::new(mulexp), Box::new(unexp)),
    <mulexp: MulExp> "%" <unexp: UnaryExp> => MulExp::Mod(Box::new(mulexp), Box::new(unexp)),
}

AddExp: AddExp = {
    <mulexp: MulExp> => AddExp::MulExp(Box::new(mulexp)),
    <addexp: AddExp> "+" <mulexp: MulExp> => AddExp::Add(Box::new(addexp), Box::new(mulexp)),
    <addexp: AddExp> "-" <mulexp: MulExp> => AddExp::Sub(Box::new(addexp), Box::new(mulexp)),
}

RelExp: RelExp = {
    <addexp: AddExp> => RelExp::AddExp(Box::new(addexp)),
    <relexp: RelExp> "<" <addexp: AddExp> => RelExp::Lt(Box::new(relexp), Box::new(addexp)),
    <relexp: RelExp> "<=" <addexp: AddExp> => RelExp::Le(Box::new(relexp), Box::new(addexp)),
    <relexp: RelExp> ">" <addexp: AddExp> => RelExp::Gt(Box::new(relexp), Box::new(addexp)),
    <relexp: RelExp> ">=" <addexp: AddExp> => RelExp::Ge(Box::new(relexp), Box::new(addexp)),
}

EqExp: EqExp = {
    <relexp: RelExp> => EqExp::RelExp(Box::new(relexp)),
    <eqexp: EqExp> "==" <relexp: RelExp> => EqExp::Eq(Box::new(eqexp), Box::new(relexp)),
    <eqexp: EqExp> "!=" <relexp: RelExp> => EqExp::Ne(Box::new(eqexp), Box::new(relexp)),
}

LAndExp: LAndExp = {
    <eqexp: EqExp> => LAndExp::EqExp(Box::new(eqexp)),
    <landexp: LAndExp> "&&" <eqexp: EqExp> => LAndExp::And(Box::new(landexp), Box::new(eqexp)),
}

LOrExp: LOrExp = {
    <landexp: LAndExp> => LOrExp::LAndExp(Box::new(landexp)),
    <lorexp: LOrExp> "||" <landexp: LAndExp> => LOrExp::Or(Box::new(lorexp), Box::new(landexp)),
}

Number: i32 = <num: IntConst> => <>;

// 如果匹配到标识符, 就返回这个字符串
// 一对尖括号在此处指代的是正则表达式匹配到的字符串 (&str)
// 关于尖括号到底代表什么, 请 RTFM
Ident: String = {
    r"[ac-zA-Z][_a-zA-Z0-9]*" => <>.to_string(),
    r"b" => <>.to_string(),
    r"b[_a-zA-Z08-9][_a-zA-Z0-9]*" => <>.to_string(),
    r"b[1-7][_a-zA-Z0-9]+" => <>.to_string(),
    <u: Underline> => u,
    <u: SingleB1To7> => format!("b{}", u).to_string(),
    <rest: r"_[_a-zA-Z0-9]+"> => rest.to_string(),
}

Underline: String = r"_" => "_".to_string();

// 对整数字面量的处理方式: 把匹配到的字符串按对应进制转换成数字
IntConst: i32 = {
  r"[8-9]" => i32::from_str_radix(<>, 10).unwrap(),
  r"[1-9][0-9]+" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]+" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
  <zero: Zero> => 0,
  <v: Single1To7> => v,
}

Zero: i32 = r"0" => 0;

Score: Score = {
    <bar: Bar> <restbar: ("|" Bar)*> => {
        let mut bars = Vec::new();
        bars.push(bar);
        for (_, item) in restbar.into_iter() {
            bars.push(item);
        }
        return Score { bars: bars };
    },
}

Bar: Bar = <notes: NoteElem+> => {
    let mut note_elems = Vec::new();
    for item in notes.into_iter() {
        note_elems.push(item);
    }
    return Bar { notes: note_elems };
};

NoteElem: NoteElem = {
    <note: Note> => NoteElem::Note(note),
    <underline: Underline> => NoteElem::Tie,
    "-" => NoteElem::Tie,
    "{" <notes: NoteElem+> "}" => {
        let mut note_elems = Vec::new();
        for item in notes.into_iter() {
            note_elems.push(Box::new(item));
        }
        return NoteElem::Notes(note_elems);
    }
}

Note: Note = {
    <dots:r":+"> <a: MidNote> => {
        let dot_count = dots.len() as i32;
        return a.up(dot_count);
    },
    <a: AfterDot> => a,
    <zero: Zero> => Note::Rest,
}

AfterDot: Note = {
    <a: MidNote> => {
        return a;
    },
    <a: MidNote> <dots:r"\.+"> => {
        let dot_count = dots.len() as i32;
        return a.up(-dot_count);
    },
}

MidNote: Note = {
    <val: Single1To7> => Note::Semitone(count_semitone(val)),
    <s: SingleB1To7> => Note::Semitone(count_semitone(s) - 1),
    r"#[1-7]" => {
        let num_str = &<>[1..];
        let s = num_str.parse::<i32>().expect("Failed to parse number");
        let new_s = count_semitone(s) + 1;
        return Note::Semitone(new_s);
    }
}

Single1To7: i32 = r"[1-7]" => i32::from_str_radix(<>, 10).unwrap();

SingleB1To7: i32 = r"b[1-7]" => {
    let num_str = &<>[1..];
    let s = num_str.parse::<i32>().expect("Failed to parse number");
    return s;
};